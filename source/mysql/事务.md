# 事务(TRANSACTION)
- 恢复和并发控制的基本单位

## ACID
- A. 原子性
- C. 一致性
- I. 隔离性
- D. 持续性

## 隔离级别

- READ UNCOMMITTED(未提交读)
    - 可脏读
    - 在一个事务未提交前, 另一个事务可以看到未提交的操作
    - 很少用
- READ COMMITTED(提交读)
    - 在一个事务提交后, 另外一个事务可以看到提交后的操作
    - 即不可重复读
    - oracle等默认是这种隔离
- REPEATTABLE READ(可重复读)
    - 一个事务提交后, 另一个事务不会看到提交后的操作
    - 即可重复读
    - 但是会出现幻读
    - MySQL默认的隔离(实际上是InnoDB的默认隔离)
- SERIALIZABLE(可串口化)
    - 最高级别的隔离
    - 强制事务串行执行
    - 可以避免幻读
    - 一般很少用
- 追加
根据SQL标准, Repeatable Read并不能消除幻读. 但是InnoDB实现上用了GAP, 可以一定程度上消除幻读.

>For locking reads (SELECT with FOR UPDATE or LOCK IN SHARE MODE), UPDATE, and DELETE statements, locking depends on whether the statement uses a unique index with a unique search condition, or a range-type search condition. For a unique index with a unique search condition, InnoDB locks only the index record found, not the gap before it. For other search conditions, InnoDB locks the index range scanned, using gap locks or next-key locks to block insertions by other sessions into the gaps covered by the range.

## InnoDB三种行锁
- Record Lock:单个行记录的锁
- Gap Lock: 间隙锁. 锁定一个范围但不包含记录本身
- Next-Key Lock: 1+2. 锁定一个范围, 并且锁定记录本身

## 死锁
- 指多个事务对同一资源上相互占用, 并请求锁定对方占用的资源.
- 资源指表一行的记录
- 判断死锁的方法:
    - 超时法, 一个事务的等待时间超过一定限制, 则认为发送了死锁. 缺点是可能会误判死锁.
    - 等待图法
- 处理方法:
    - 选择一个处理死锁代价最高的事务, 将其撤销, 释放此事务的锁.

## 悲观并发控制(Pessimistic Concurrency Control)
- 最常见的并发控制机制
- 也就是锁

## 乐观并发控制(Optimistic Concurrency Control)
- 也叫乐观锁, 但不是真实存在的锁
- 通过版本号实现读取

## MVCC(Multi Version Concurrency Control)多版本并发控制
- 可以认为MVCC是行级锁的变种
- 最大好处: 读不加锁, 写加悲观锁, 读写不冲突
- 不管需要执行多长时间, 每个事务看到的数据都是一致的; 根据事务开始的时间不同, 每个事务对同一张表, 同一时刻看到的数据可能是不一样的.
- 不同存储引擎实现MVCC的方式是不同的
    - 乐观(optimistic)并发控制
    - 悲观(pessimistic)并发控制
- MVCC只在REAPEATABLE READ和READ COMMITED两个隔离级别下工作, 因为READ UNCOMMITED恒读最新的数据, SERIALIZER一直加锁.

# MySQl的存储引擎

## InnoDB存储引擎
- InnoDB是MySQL的默认事务型引擎

## MyISAM存储引擎
- MySQL5.1前默认的存储引擎
- 不支持事务和行级锁

### InnoDB事务模型和锁
- InnoDB实现两种标准**行级锁**: **共享锁(share lock, 读锁, S锁), 排他锁(exclusive lock, 写锁, X锁)**
    - 共享锁: 持有共享锁的事务允许其他事务读取该行记录, 但试图进行更新或删除的事务会被阻塞, 知道持有共享锁的事务commit. 
    - 排他锁: 持有排他锁的事务, 不允许其他事务对同一行记录加锁. **更新操作时会自动加排他锁**, 其他事务的更新操作会被阻塞, 直到上个事务被commit. 具体还跟隔离级别有关, InnoDB的默认隔离时Repeatable READ, 即更新被阻塞, 查询可以执行.
        - 对于```更新操作时会自动加排他锁```这句话过了很久之后才明白. 例如两个并发的更新事务, 他们都是要对某个字段进行自增操作. 以前会错误地以为: 自增操作包含先把字段读出来; 然后进行自增; 最后把值赋给该字段这三个操作. 由于MySql默认时RR隔离级别, 所以一个事务自增后, 另一个事务把该字段读出来仍然是没有自增的值, 所以会导致结果不符合一致性. 但实际上, 由于```更新操作时会自动加排他锁```, 所以另一个事务进行更新操作时会被阻塞, 从而不存在上述问题.
- 数据粒度
    - 即加锁的数据对象
    - 分为:
        - 行级锁
            - 开销大, 速度慢, 粒度最小, 发生锁冲突的可能性小, 会出现死锁, 并发度最高
        - 表级锁
            - 相反
- **意向锁(Intention Locks)**
    - 表级锁
    - 是为了解决表锁和行锁的冲突问题:
        - 当一个事务申请了行锁, 然后另外一个事务申请了表锁, 要使得两个事务不冲突, 第二个事务申请的时候就要一行一行检查是否已经有行锁, 这样的效率很低.
        - 意向锁就是在一个事务申请行锁时, 同时会给整个表加上意向锁, 这样第二个事务申请锁的时候就能知道已经有事务申请了行锁.
        - 申请意向锁的动作是数据库实现的, 不需要代码申请
        - 有意向共享锁(IS)和意向排他锁(IX)