# Celery初步

## 前置知识 

- 中间人(broker)
    - 是传递消息的中间件. 当应用程序调用celery的任务时, 会向broker发送消息, 然后worker取得消息, 执行相应的程序.
    - broker生产环境只支持RabbitMQ和redis.
- backend
    - 用于存储发送的消息, 和celery执行的消息和结果
- 职程(worker)
- 任务队列(task queue)
    - 在线程或机器间分发任务的机制
- 消息队列(message queue)
- IPC(Inter-Process Communication), 进程间通信
    - 管道, 用于短小,频率很高的消息
        - 匿名管道(pipe)
        - 有名管道(FIFO)
    - 信号量(semophore)
    - 消息队列(message queue)
    - 信号(signal)
    - 共享内存(shared memory)
    - 套接字(socket), 用于分布式
        - socket的特性由三个属性确定: 域, 端口号, 协议类型
- serialization: 把在内存(memory)的对象(object), 转化为stream of bytes, 这样可以把它存储在磁盘上, 或者通过network传输. Deserialization是反过来

## 运行celery职程服务器
**tasks.py
```python
from celery import Celery


app = Celery('tasks', broker='ampq://guest@localhost//')

@app.task
def add(x, y):
    return x+y
```

输入: ```celery -A tasks worker --loglevel=info```启动
 - **坑**: 在windows下, 执行该命令会报```No module named 'kombu.asynchronous.timer'```错误, 打开venv文件夹, 把kombu文件夹删掉就可以了, 原因不明.

 ## 调用任务

 ```python
 from task import add

 add.delay(4, 4)
 ```
 - **坑**: window下在celery4.0+中, 会提示失败; 把celery卸载, ```pip install celery=3.1.24```之后执行成功. 因为celery4.0+之后不再支持windows.